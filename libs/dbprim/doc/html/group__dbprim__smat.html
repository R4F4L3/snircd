<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Sparse matrices</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.8.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; </center>
<hr><h1>Sparse matrices</h1>Operations for sparse matrices. 
<a href="#_details">More...</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a21">SMAT_TABLE_INIT</a>(flags, resize, extra)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix table static initializer.</em> <a href="#a21">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a22">st_verify</a>(table)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix table verification macro.</em> <a href="#a22">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a23">st_flags</a>(table)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix table flags.</em> <a href="#a23">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a24">st_frozen</a>(table)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Determine if a sparse matrix is frozen.</em> <a href="#a24">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a25">st_modulus</a>(table)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix table modulus.</em> <a href="#a25">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a26">st_count</a>(table)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix table count.</em> <a href="#a26">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a27">st_extra</a>(table)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Extra pointer data in a sparse matrix table.</em> <a href="#a27">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a28">st_size</a>(table)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix table memory size.</em> <a href="#a28">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a29">SMAT_HEAD_INIT</a>(elem, object)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix list head static initializer.</em> <a href="#a29">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a30">sh_verify</a>(head)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix list head verification macro.</em> <a href="#a30">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a31">sh_elem</a>(head)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix list head element macro.</em> <a href="#a31">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a32">sh_table</a>(head)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix list head table pointer.</em> <a href="#a32">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a33">sh_frozen</a>(head)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Determine if a sparse matrix is frozen.</em> <a href="#a33">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a34">sh_count</a>(head)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix list count.</em> <a href="#a34">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a35">sh_first</a>(head)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>First element in sparse matrix list.</em> <a href="#a35">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a36">sh_last</a>(head)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Last element in sparse matrix list.</em> <a href="#a36">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a37">sh_object</a>(head)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Object represented by a sparse matrix list head.</em> <a href="#a37">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a38">sh_size</a>(head)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix list memory size.</em> <a href="#a38">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a39">se_verify</a>(entry)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix entry verification macro.</em> <a href="#a39">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a40">se_table</a>(entry)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix entry table.</em> <a href="#a40">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a41">_se_link</a>(entry)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix entry linked list element.</em> <a href="#a41">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a42">se_flags</a>(entry)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix entry flags.</em> <a href="#a42">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a43">se_hash</a>(entry)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix table entry hash value.</em> <a href="#a43">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a44">se_next</a>(entry, n)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Next element in sparse matrix list.</em> <a href="#a44">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a45">se_prev</a>(entry, n)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Previous element in sparse matrix list.</em> <a href="#a45">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a46">se_lflags</a>(entry, n)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Flags associated with an entry in a sparse matrix list.</em> <a href="#a46">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a47">se_object</a>(entry, n)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Object associated with an entry in a sparse matrix list.</em> <a href="#a47">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td nowrap align=right valign=top>typedef struct _smat_table_s&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix table.</em> <a href="#a0">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>typedef struct _smat_head_s&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix list head.</em> <a href="#a1">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>typedef struct _smat_entry_s&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix entry.</em> <a href="#a2">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>typedef unsigned long (*&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a3">smat_resize_t</a> )(<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> *, unsigned long)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix table resize callback.</em> <a href="#a3">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>typedef unsigned long (*&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a4">smat_iter_t</a> )(<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> *, <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> *, void *)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix iteration callback.</em> <a href="#a4">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>typedef unsigned long (*&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a5">smat_comp_t</a> )(<a class="el" href="group__dbprim__key.html#a0">db_key_t</a> *, <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> *)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix comparison callback.</em> <a href="#a5">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>typedef enum <a class="el" href="group__dbprim__smat.html#a48">_smat_loc_e</a>&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a6">smat_loc_t</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix location.</em> <a href="#a6">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Enumerations</h2></td></tr>
<tr><td nowrap align=right valign=top>enum &nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a48">_smat_loc_e</a> { <a class="el" href="group__dbprim__smat.html#a48a102">SMAT_LOC_FIRST</a>, 
<a class="el" href="group__dbprim__smat.html#a48a103">SMAT_LOC_SECOND</a>
 }</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sparse matrix location.</em> <a href="#a48">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a7">smat_cleanup</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Clean up the smat free list.</em> <a href="#a7">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a8">smat_freemem</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Report how much memory is used by the free list.</em> <a href="#a8">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a9">st_init</a> (<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> *table, unsigned long flags, <a class="el" href="group__dbprim__smat.html#a3">smat_resize_t</a> resize, void *extra, unsigned long init_mod)</td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a10">st_add</a> (<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> *table, <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> **entry_p, <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> *head1, <a class="el" href="group__dbprim__link.html#a4">link_loc_t</a> loc1, <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> *ent1, <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> *head2, <a class="el" href="group__dbprim__link.html#a4">link_loc_t</a> loc2, <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> *ent2)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Add an entry to a sparse matrix.</em> <a href="#a10">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a11">st_remove</a> (<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> *table, <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> *entry)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Remove an entry from a sparse matrix.</em> <a href="#a11">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a12">st_find</a> (<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> *table, <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> **entry_p, <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> *head1, <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> *head2)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Find an entry in a sparse matrix.</em> <a href="#a12">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a13">st_iter</a> (<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> *table, <a class="el" href="group__dbprim__smat.html#a4">smat_iter_t</a> iter_func, void *extra)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Iterate over each entry in a sparse matrix.</em> <a href="#a13">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a14">st_flush</a> (<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> *table, <a class="el" href="group__dbprim__smat.html#a4">smat_iter_t</a> flush_func, void *extra)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Flush a sparse matrix.</em> <a href="#a14">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a15">st_resize</a> (<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> *table, unsigned long new_size)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Resize a sparse matrix table.</em> <a href="#a15">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a16">st_free</a> (<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> *table)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Free memory used by an empty sparse matrix table.</em> <a href="#a16">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a17">sh_init</a> (<a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> *head, <a class="el" href="group__dbprim__smat.html#a6">smat_loc_t</a> elem, void *object)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Dynamically initialize a sparse matrix row or column head.</em> <a href="#a17">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a18">sh_move</a> (<a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> *head, <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> *elem, <a class="el" href="group__dbprim__link.html#a4">link_loc_t</a> loc, <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> *elem2)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Move an entry within a row or column list.</em> <a href="#a18">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a19">sh_find</a> (<a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> *head, <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> **elem_p, <a class="el" href="group__dbprim__smat.html#a5">smat_comp_t</a> comp_func, <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> *start, <a class="el" href="group__dbprim__key.html#a0">db_key_t</a> *key)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Find an entry in a row or column of a sparse matrix.</em> <a href="#a19">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>unsigned long&nbsp;</td><td valign=bottom><a class="el" href="group__dbprim__smat.html#a20">sh_iter</a> (<a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> *head, <a class="el" href="group__dbprim__smat.html#a4">smat_iter_t</a> iter_func, void *extra)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Iterate over each entry in a row or column of a sparse matrix.</em> <a href="#a20">More...</a><em></em></font><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Sparse matrices are advanced data structures used to represent associations. For instance, a manager may have several employees, but several of those employees may report to more than one manager. (Yes, this is a contrived example, so sue me.) The simplest way to represent such assocations is with a matrix, or a two-dimensional array. However, such an implementation cannot easily be extended dynamically--imagine if a manager retires and two more are hired, for instance. It would also use an enormous amount of memory, as most employees would only report to one or two managers.
<p>
A sparse matrix solves this problem by only allocating memory for the cells in the full matrix which are actually used. That is, no memory is allocated to represent Alice reporting to Bob unless Alice actually does report to Bob. This is a simple concept, but fairly difficult to implement efficiently--how do you tell if Alice reports to Bob? The solution utilized by this library is to combine the strengths of linked lists and hash tables. Each cell is in two linked lists, rooted at the rows and columns of the matrix, but a hash table is used when attempting to look up a given cell. If the cell is allocated, then there will be an entry in the hash table, and finding the given cell is as fast as a hash table look-up.
<p>
Because sparse matrices are so complicated, there are three structures and a variety of operations used. Two of the structures, <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> and <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>, are caller-allocated. However, the third structure, <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>, must be allocated by the library. To avoid too much overhead from malloc(), a free list is used. The free list may be managed with the <a class="el" href="group__dbprim__smat.html#a7">smat_cleanup</a>() and <a class="el" href="group__dbprim__smat.html#a8">smat_freemem</a>() calls.
<p>
The <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> contains the hash table. Only one of these need be allocated per type of association--for instance, in the above example, only one <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> needs to be allocated to represent the manager-employee relationship.
<p>
The <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> contains the linked list. There are actually two kinds of these structures--one is <a class="el" href="group__dbprim__smat.html#a48a102">SMAT_LOC_FIRST</a>, which could be regarded as a ``row,'' and the other is <a class="el" href="group__dbprim__smat.html#a48a103">SMAT_LOC_SECOND</a>, which could be regarded as a ``column.'' Which one is used for which type of data is irrelevant, as long as consistency is maintained. For the above example, a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> for a manager may be <a class="el" href="group__dbprim__smat.html#a48a102">SMAT_LOC_FIRST</a>, and one for an employee must then be <a class="el" href="group__dbprim__smat.html#a48a103">SMAT_LOC_SECOND</a>. (These values are set when initializing the <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> structure.)
<p>
An association may be created with the <a class="el" href="group__dbprim__smat.html#a10">st_add</a>() function, which allows an arbitrary ordering in the associated linked lists by the same mechanism as for the linked list component of the library. An association may be removed with <a class="el" href="group__dbprim__smat.html#a11">st_remove</a>(), or looked up with <a class="el" href="group__dbprim__smat.html#a12">st_find</a>(). If iteration over all associations is desired, use the <a class="el" href="group__dbprim__smat.html#a13">st_iter</a>() function. Removing all associations from a table may be performed with <a class="el" href="group__dbprim__smat.html#a14">st_flush</a>(), which optionally calls a user-defined clean-up function. The associated hash table may be resized with <a class="el" href="group__dbprim__smat.html#a15">st_resize</a>(), and the bucket table may be released with <a class="el" href="group__dbprim__smat.html#a16">st_free</a>().
<p>
An association may also be reordered within the linked lists using the <a class="el" href="group__dbprim__smat.html#a18">sh_move</a>() function. If a particular entry is desired, use the <a class="el" href="group__dbprim__smat.html#a19">sh_find</a>() function with a user-defined comparison function to locate it. Iteration may be performed with the <a class="el" href="group__dbprim__smat.html#a20">sh_iter</a>() function, and all entries in a given linked list may be removed with the sh_flush() function, which again may optionally call a user-defined clean-up function. <hr><h2>Define Documentation</h2>
<a name="a29" doxytag="dbprim.h.top::SMAT_HEAD_INIT"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define SMAT_HEAD_INIT(
          </b></td>
          <td valign="bottom"><b>
elem, object&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro statically initializes a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>elem</em>
&nbsp;</td><td>
One of <a class="el" href="group__dbprim__smat.html#a48a102">SMAT_LOC_FIRST</a> or <a class="el" href="group__dbprim__smat.html#a48a103">SMAT_LOC_SECOND</a> specifing whether the object is a member of the set of rows or columns. </td></tr>
<tr><td valign=top><em>object</em>
&nbsp;</td><td>
A pointer to <code>void</code> representing the object associated with the list head. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a21" doxytag="dbprim.h.top::SMAT_TABLE_INIT"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define SMAT_TABLE_INIT(
          </b></td>
          <td valign="bottom"><b>
flags, resize, extra&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro statically initializes a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>flags</em>
&nbsp;</td><td>
A bit-wise OR of <a class="el" href="group__dbprim__hash.html#a16">HASH_FLAG_AUTOGROW</a> and <a class="el" href="group__dbprim__hash.html#a17">HASH_FLAG_AUTOSHRINK</a>. If neither behavior is desired, use 0. </td></tr>
<tr><td valign=top><em>resize</em>
&nbsp;</td><td>
A <a class="el" href="group__dbprim__smat.html#a3">smat_resize_t</a> function pointer for determining whether resizing is permitted and/or for notification of the resize. </td></tr>
<tr><td valign=top><em>extra</em>
&nbsp;</td><td>
Extra pointer data that should be associated with the sparse matrix. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a41" doxytag="dbprim.h.top::_se_link"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define _se_link(
          </b></td>
          <td valign="bottom"><b>
entry&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
For internal use only.    </td>
  </tr>
</table>
<a name="a42" doxytag="dbprim.h.top::se_flags"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define se_flags(
          </b></td>
          <td valign="bottom"><b>
entry&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro retrieves a set of user-defined flags associated with the entry. It may be used as an lvalue to set those flags.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>entry</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
An <code>unsigned long</code> containing the flags associated with the entry. </dl>    </td>
  </tr>
</table>
<a name="a43" doxytag="dbprim.h.top::se_hash"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define se_hash(
          </b></td>
          <td valign="bottom"><b>
entry&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro retrieves the hash value of the given sparse matrix entry. If the sparse matrix hash been resized, this value may not be the same as a previous value.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>entry</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
An <code>unsigned long</code> containing the hash code for the entry. </dl>    </td>
  </tr>
</table>
<a name="a46" doxytag="dbprim.h.top::se_lflags"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define se_lflags(
          </b></td>
          <td valign="bottom"><b>
entry, n&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro retrieves a set of user-defined flags associated with the entry in a sparse matrix list. It may be used as an lvalue to set those flags.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>entry</em>
&nbsp;</td><td>
A pointer to <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. </td></tr>
<tr><td valign=top><em>n</em>
&nbsp;</td><td>
One of <a class="el" href="group__dbprim__smat.html#a48a102">SMAT_LOC_FIRST</a> or <a class="el" href="group__dbprim__smat.html#a48a103">SMAT_LOC_SECOND</a> to specify which list thread is desired.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
An <code>unsigned long</code> containing the flags associated with the entry. </dl>    </td>
  </tr>
</table>
<a name="a44" doxytag="dbprim.h.top::se_next"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define se_next(
          </b></td>
          <td valign="bottom"><b>
entry, n&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro retrieves a pointer to the <a class="el" href="group__dbprim__link.html#a1">link_elem_t</a> for the next element in the sparse matrix list.
<p>
<dl compact><dt>
<b>Warning: </b><dd>
This macro may evaluate the <code>entry</code> and <code>n</code> arguments twice.</dl><dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>entry</em>
&nbsp;</td><td>
A pointer to <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. </td></tr>
<tr><td valign=top><em>n</em>
&nbsp;</td><td>
One of <a class="el" href="group__dbprim__smat.html#a48a102">SMAT_LOC_FIRST</a> or <a class="el" href="group__dbprim__smat.html#a48a103">SMAT_LOC_SECOND</a> to specify which list thread is desired.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
A pointer to <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. </dl>    </td>
  </tr>
</table>
<a name="a47" doxytag="dbprim.h.top::se_object"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define se_object(
          </b></td>
          <td valign="bottom"><b>
entry, n&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro retrieves a pointer to one of the object represented by the entry. It may be used as an lvalue to change the object pointed to. Care should be taken when using this feature.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>entry</em>
&nbsp;</td><td>
A pointer to <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. </td></tr>
<tr><td valign=top><em>n</em>
&nbsp;</td><td>
One of <a class="el" href="group__dbprim__smat.html#a48a102">SMAT_LOC_FIRST</a> or <a class="el" href="group__dbprim__smat.html#a48a103">SMAT_LOC_SECOND</a> to specify which list thread is desired.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
A pointer to <code>void</code> representing the object. </dl>    </td>
  </tr>
</table>
<a name="a45" doxytag="dbprim.h.top::se_prev"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define se_prev(
          </b></td>
          <td valign="bottom"><b>
entry, n&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro retrieves a pointer to the <a class="el" href="group__dbprim__link.html#a1">link_elem_t</a> for the previous element in the sparse matrix list.
<p>
<dl compact><dt>
<b>Warning: </b><dd>
This macro may evaluate the <code>entry</code> and <code>n</code> arguments twice.</dl><dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>entry</em>
&nbsp;</td><td>
A pointer to <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. </td></tr>
<tr><td valign=top><em>n</em>
&nbsp;</td><td>
One of <a class="el" href="group__dbprim__smat.html#a48a102">SMAT_LOC_FIRST</a> or <a class="el" href="group__dbprim__smat.html#a48a103">SMAT_LOC_SECOND</a> to specify which list thread is desired.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
A pointer to <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. </dl>    </td>
  </tr>
</table>
<a name="a40" doxytag="dbprim.h.top::se_table"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define se_table(
          </b></td>
          <td valign="bottom"><b>
entry&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro retrieves a pointer to the table that the sparse matrix entry is in.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>entry</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>. </dl>    </td>
  </tr>
</table>
<a name="a39" doxytag="dbprim.h.top::se_verify"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define se_verify(
          </b></td>
          <td valign="bottom"><b>
entry&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro verifies that a given pointer actually does point to a sparse matrix entry.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>entry</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
Boolean true if <code>entry</code> is a valid sparse matrix entry or false otherwise. </dl>    </td>
  </tr>
</table>
<a name="a34" doxytag="dbprim.h.top::sh_count"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define sh_count(
          </b></td>
          <td valign="bottom"><b>
head&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro retrieves the number of elements in the sparse matrix list rooted at <code>head</code>.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>head</em>
&nbsp;</td><td>
A pointer to <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
An <code>unsigned long</code> containing a count of the number of elements in the sparse matrix list. </dl>    </td>
  </tr>
</table>
<a name="a31" doxytag="dbprim.h.top::sh_elem"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define sh_elem(
          </b></td>
          <td valign="bottom"><b>
head&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro retrieves the position indicator for the sparse matrix head. It will return one of <a class="el" href="group__dbprim__smat.html#a48a102">SMAT_LOC_FIRST</a> or <a class="el" href="group__dbprim__smat.html#a48a103">SMAT_LOC_SECOND</a>.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>head</em>
&nbsp;</td><td>
A pointer to <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
An <a class="el" href="group__dbprim__smat.html#a6">smat_loc_t</a>. </dl>    </td>
  </tr>
</table>
<a name="a35" doxytag="dbprim.h.top::sh_first"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define sh_first(
          </b></td>
          <td valign="bottom"><b>
head&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro retrieves a pointer to the <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> for the first element in the sparse matrix list.
<p>
<dl compact><dt>
<b>Warning: </b><dd>
This macro may evaluate the <code>head</code> argument twice.</dl><dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>head</em>
&nbsp;</td><td>
A pointer to <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
A pointer to <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. </dl>    </td>
  </tr>
</table>
<a name="a33" doxytag="dbprim.h.top::sh_frozen"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define sh_frozen(
          </b></td>
          <td valign="bottom"><b>
head&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro returns a non-zero value if the matrix is currently frozen. The sparse matrix may be frozen if there is an iteration in progress.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>head</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
A zero value if the matrix is not frozen or a non-zero value if the matrix is frozen. </dl>    </td>
  </tr>
</table>
<a name="a36" doxytag="dbprim.h.top::sh_last"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define sh_last(
          </b></td>
          <td valign="bottom"><b>
head&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro retrieves a pointer to the <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> for the last element in the sparse matrix list.
<p>
<dl compact><dt>
<b>Warning: </b><dd>
This macro may evaluate the <code>head</code> argument twice.</dl><dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>head</em>
&nbsp;</td><td>
A pointer to <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
A pointer to <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. </dl>    </td>
  </tr>
</table>
<a name="a37" doxytag="dbprim.h.top::sh_object"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define sh_object(
          </b></td>
          <td valign="bottom"><b>
head&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro retrieves a pointer to the object referenced by the sparse matrix list head.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>head</em>
&nbsp;</td><td>
A pointer to <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
A pointer to <code>void</code>. </dl>    </td>
  </tr>
</table>
<a name="a38" doxytag="dbprim.h.top::sh_size"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define sh_size(
          </b></td>
          <td valign="bottom"><b>
head&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro returns the physical size of the memory allocated by the library for this sparse matrix list.
<p>
<dl compact><dt>
<b>Note: </b><dd>
The <a class="el" href="group__dbprim__smat.html#a28">st_size</a>() macro already counts the memory for each list in the table. Summing the results of <a class="el" href="group__dbprim__smat.html#a38">sh_size</a>() and <a class="el" href="group__dbprim__smat.html#a28">st_size</a>() will over-count the amount of memory actually in use.</dl><dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>head</em>
&nbsp;</td><td>
A pointer to <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
A <code>size_t</code>. </dl>    </td>
  </tr>
</table>
<a name="a32" doxytag="dbprim.h.top::sh_table"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define sh_table(
          </b></td>
          <td valign="bottom"><b>
head&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 If there are any elements in this sparse matrix list head, this macro will retrieve a pointer to the table in which they reside.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>head</em>
&nbsp;</td><td>
A pointer to <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
A pointer to <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>. </dl>    </td>
  </tr>
</table>
<a name="a30" doxytag="dbprim.h.top::sh_verify"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define sh_verify(
          </b></td>
          <td valign="bottom"><b>
head&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro verifies that a given pointer actually does point to a sparse matrix head.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>head</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
Boolean true if <code>head</code> is a valid sparse matrix head or false otherwise. </dl>    </td>
  </tr>
</table>
<a name="a26" doxytag="dbprim.h.top::st_count"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define st_count(
          </b></td>
          <td valign="bottom"><b>
table&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro retrieves the total number of items actually in the sparse matrix table.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>table</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
An <code>unsigned long</code> containing a count of the number of items in the sparse matrix table. </dl>    </td>
  </tr>
</table>
<a name="a27" doxytag="dbprim.h.top::st_extra"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define st_extra(
          </b></td>
          <td valign="bottom"><b>
table&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro retrieves the extra pointer data associated with a particular sparse matrix table.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>table</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
A pointer to <code>void</code>. </dl>    </td>
  </tr>
</table>
<a name="a23" doxytag="dbprim.h.top::st_flags"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define st_flags(
          </b></td>
          <td valign="bottom"><b>
table&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro retrieves the flags associated with the sparse matrix table. Only <a class="el" href="group__dbprim__hash.html#a16">HASH_FLAG_AUTOGROW</a> and <a class="el" href="group__dbprim__hash.html#a17">HASH_FLAG_AUTOSHRINK</a> have any meaning to the application; all other bits are reserved for use in the library. This macro may be used as an lvalue, but care must be taken to avoid modifying the library-specific bits.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>table</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
An <code>unsigned long</code> containing the flags for the sparse matrix table. </dl>    </td>
  </tr>
</table>
<a name="a24" doxytag="dbprim.h.top::st_frozen"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define st_frozen(
          </b></td>
          <td valign="bottom"><b>
table&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro returns a non-zero value if the matrix is currently frozen. The sparse matrix may be frozen if there is an iteration in progress.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>table</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
A zero value if the matrix is not frozen or a non-zero value if the matrix is frozen. </dl>    </td>
  </tr>
</table>
<a name="a25" doxytag="dbprim.h.top::st_modulus"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define st_modulus(
          </b></td>
          <td valign="bottom"><b>
table&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro retrieves the number of buckets allocated for the sparse matrix table. An application may wish to save this value between invocations to avoid the overhead of growing the table while filling it with data.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>table</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
An <code>unsigned long</code> containing the number of buckets allocated for the sparse matrix table. </dl>    </td>
  </tr>
</table>
<a name="a28" doxytag="dbprim.h.top::st_size"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define st_size(
          </b></td>
          <td valign="bottom"><b>
table&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro returns the physical size of the memory allocated by the library for this sparse matrix table.
<p>
<dl compact><dt>
<b>Note: </b><dd>
The <a class="el" href="group__dbprim__smat.html#a28">st_size</a>() macro already counts the memory for each list in the table. Summing the results of <a class="el" href="group__dbprim__smat.html#a38">sh_size</a>() and <a class="el" href="group__dbprim__smat.html#a28">st_size</a>() will over-count the amount of memory actually in use.</dl><dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>table</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
A <code>size_t</code>. </dl>    </td>
  </tr>
</table>
<a name="a22" doxytag="dbprim.h.top::st_verify"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define st_verify(
          </b></td>
          <td valign="bottom"><b>
table&nbsp;)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This macro verifies that a given pointer actually does point to a sparse matrix table.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>table</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>.
<p>
</td></tr>
</table>
</dl><dl compact><dt>
<b>Returns: </b><dd>
Boolean true if <code>table</code> is a valid sparse matrix table or false otherwise. </dl>    </td>
  </tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a name="a5" doxytag="dbprim.h.top::smat_comp_t"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
typedef unsigned long(* smat_comp_t)(<a class="el" href="group__dbprim__key.html#a0">db_key_t</a> *, <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> *)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This function pointer references a callback used by <a class="el" href="group__dbprim__smat.html#a19">sh_find</a>(). It should return 0 if the sparse matrix entry represented by the second argument matches the key passed as the first argument.     </td>
  </tr>
</table>
<a name="a2" doxytag="dbprim.h.top::smat_entry_t"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
typedef struct _smat_entry_s smat_entry_t
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This structure is allocated by the library and represents a single element in a sparse matrix.     </td>
  </tr>
</table>
<a name="a1" doxytag="dbprim.h.top::smat_head_t"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
typedef struct _smat_head_s smat_head_t
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This structure is the head of a linked list of sparse matrix entries.     </td>
  </tr>
</table>
<a name="a4" doxytag="dbprim.h.top::smat_iter_t"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
typedef unsigned long(* smat_iter_t)(<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> *, <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> *, void *)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This function pointer references a callback used by <a class="el" href="group__dbprim__smat.html#a13">st_iter</a>(), <a class="el" href="group__dbprim__smat.html#a14">st_flush</a>(), <a class="el" href="group__dbprim__smat.html#a20">sh_iter</a>(), and sh_flush(). It should return 0 for success. A non-zero return value will terminate the operation and will become the return value of the call.     </td>
  </tr>
</table>
<a name="a6" doxytag="dbprim.h.top::smat_loc_t"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
typedef enum <a class="el" href="group__dbprim__smat.html#a48">_smat_loc_e</a> smat_loc_t
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 See the documentation for the enumeration <a class="el" href="group__dbprim__smat.html#a48">_smat_loc_e</a>.     </td>
  </tr>
</table>
<a name="a3" doxytag="dbprim.h.top::smat_resize_t"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
typedef unsigned long(* smat_resize_t)(<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> *, unsigned long)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This function pointer references a callback that will be called with both the old and new sparse matrix table sizes whenever a sparse matrix's hash table table is resized. It should return non-zero only when the resize should be inhibited.     </td>
  </tr>
</table>
<a name="a0" doxytag="dbprim.h.top::smat_table_t"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
typedef struct _smat_table_s smat_table_t
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This structure is the basis of all sparse matrices maintained by this library.     </td>
  </tr>
</table>
<hr><h2>Enumeration Type Documentation</h2>
<a name="a48" doxytag="dbprim.h.top::_smat_loc_e"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
enum _smat_loc_e
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This enumeration is used to specify whether an element is a row or column element. It should be referenced by the typedef <a class="el" href="group__dbprim__smat.html#a6">smat_loc_t</a>. <dl compact><dt>
<b>Enumeration values:</b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><a name="a48a102" doxytag="SMAT_LOC_FIRST"></a><em>SMAT_LOC_FIRST</em>
&nbsp;</td><td>
First entry (``row''). </td></tr>
<tr><td valign=top><a name="a48a103" doxytag="SMAT_LOC_SECOND"></a><em>SMAT_LOC_SECOND</em>
&nbsp;</td><td>
Second entry (``column''). </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a19" doxytag="sh_find.c::sh_find"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned long sh_find (
          </b></td>
          <td valign="bottom"><b>
<a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> * <em>head</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> ** <em>elem_p</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a5">smat_comp_t</a> <em>comp_func</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> * <em>start</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__key.html#a0">db_key_t</a> * <em>key</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This function iterates through the given row or column of a sparse matrix looking for an element that matches the given <code>key</code>.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>head</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>. </td></tr>
<tr><td valign=top><em>elem_p</em>
&nbsp;</td><td>
A pointer to a pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. This is a result pramater. <code>NULL</code> is an invalid value. </td></tr>
<tr><td valign=top><em>comp_func</em>
&nbsp;</td><td>
A pointer to a comparison function used to compare the key to a particular entry. See the documentation for <a class="el" href="group__dbprim__smat.html#a5">smat_comp_t</a> for more information. </td></tr>
<tr><td valign=top><em>start</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> describing where in the row or column to start. If <code>NULL</code> is passed, the beginning of the row or column will be assumed. </td></tr>
<tr><td valign=top><em>key</em>
&nbsp;</td><td>
A key to search for.</td></tr>
</table>
</dl><dl compact><dt>
<b>Return values: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DB_ERR_BADARGS</em>
&nbsp;</td><td>
An argument was invalid. </td></tr>
<tr><td valign=top><em>DB_ERR_WRONGTABLE</em>
&nbsp;</td><td>
<code>start</code> is not in this row or column. </td></tr>
<tr><td valign=top><em>DB_ERR_NOENTRY</em>
&nbsp;</td><td>
No matching entry was found. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a17" doxytag="sh_init.c::sh_init"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned long sh_init (
          </b></td>
          <td valign="bottom"><b>
<a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> * <em>head</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a6">smat_loc_t</a> <em>elem</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
void * <em>object</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This function dynamically initializes a sparse matrix row or column linked list head. The <code>elem</code> argument specifies whether the object is to be associated with a <a class="el" href="group__dbprim__smat.html#a48a102">SMAT_LOC_FIRST</a> list or a <a class="el" href="group__dbprim__smat.html#a48a103">SMAT_LOC_SECOND</a> list.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>head</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> to be initialized. </td></tr>
<tr><td valign=top><em>elem</em>
&nbsp;</td><td>
Either <a class="el" href="group__dbprim__smat.html#a48a102">SMAT_LOC_FIRST</a> or <a class="el" href="group__dbprim__smat.html#a48a103">SMAT_LOC_SECOND</a>. </td></tr>
<tr><td valign=top><em>object</em>
&nbsp;</td><td>
A pointer to the object containing the sparse matrix row or column head.</td></tr>
</table>
</dl><dl compact><dt>
<b>Return values: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DB_ERR_BADARGS</em>
&nbsp;</td><td>
An invalid argument was given. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a20" doxytag="sh_iter.c::sh_iter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned long sh_iter (
          </b></td>
          <td valign="bottom"><b>
<a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> * <em>head</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a4">smat_iter_t</a> <em>iter_func</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
void * <em>extra</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This function iterates over a row or column of a sparse matrix, executing the given <code>iter_func</code> for each entry.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>head</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>. </td></tr>
<tr><td valign=top><em>iter_func</em>
&nbsp;</td><td>
A pointer to a callback function used to perform user-specified actions on an entry in a row or column of a sparse matrix. <code>NULL</code> is an invalid value. See the documentation for <a class="el" href="group__dbprim__smat.html#a4">smat_iter_t</a> for more information. </td></tr>
<tr><td valign=top><em>extra</em>
&nbsp;</td><td>
A <code>void</code> pointer that will be passed to <code>iter_func</code>.</td></tr>
</table>
</dl><dl compact><dt>
<b>Return values: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DB_ERR_BADARGS</em>
&nbsp;</td><td>
An argument was invalid. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a18" doxytag="sh_move.c::sh_move"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned long sh_move (
          </b></td>
          <td valign="bottom"><b>
<a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> * <em>head</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> * <em>elem</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__link.html#a4">link_loc_t</a> <em>loc</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> * <em>elem2</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This function allows the specified entry to be shifted within the linked list describing the row or column. It is very similar to the <a class="el" href="group__dbprim__link.html#a7">ll_move</a>() function.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>head</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a>. </td></tr>
<tr><td valign=top><em>elem</em>
&nbsp;</td><td>
A pointer to the <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> describing the entry to be moved. </td></tr>
<tr><td valign=top><em>loc</em>
&nbsp;</td><td>
A <a class="el" href="group__dbprim__link.html#a4">link_loc_t</a> indicating where the entry should be moved to. </td></tr>
<tr><td valign=top><em>elem2</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> describing another entry in the list if <code>loc</code> is <a class="el" href="group__dbprim__link.html#a26a100">LINK_LOC_BEFORE</a> or <a class="el" href="group__dbprim__link.html#a26a101">LINK_LOC_AFTER</a>.</td></tr>
</table>
</dl><dl compact><dt>
<b>Return values: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DB_ERR_BADARGS</em>
&nbsp;</td><td>
An argument was invalid. </td></tr>
<tr><td valign=top><em>DB_ERR_BUSY</em>
&nbsp;</td><td>
<code>elem</code> and <code>elem2</code> are the same entry. </td></tr>
<tr><td valign=top><em>DB_ERR_WRONGTABLE</em>
&nbsp;</td><td>
<code>elem</code> or <code>elem2</code> are in a different row or column. </td></tr>
<tr><td valign=top><em>DB_ERR_UNUSED</em>
&nbsp;</td><td>
<code>elem</code> or <code>elem2</code> are not in any row or column. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a7" doxytag="smat_freelist.c::smat_cleanup"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned long smat_cleanup (
          </b></td>
          <td valign="bottom"><b>
void&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This function frees all smat_entry_t objects on the internal free list. It is always successful and returns 0.     </td>
  </tr>
</table>
<a name="a8" doxytag="smat_freelist.c::smat_freemem"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned long smat_freemem (
          </b></td>
          <td valign="bottom"><b>
void&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This function returns the amount of memory being used by the internal free list of smat_entry_t objects.
<p>
<dl compact><dt>
<b>Returns: </b><dd>
A number indicating the size, in bytes, of the memory allocated for smat_entry_t objects on the free list. </dl>    </td>
  </tr>
</table>
<a name="a10" doxytag="st_add.c::st_add"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned long st_add (
          </b></td>
          <td valign="bottom"><b>
<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> * <em>table</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> ** <em>entry_p</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> * <em>head1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__link.html#a4">link_loc_t</a> <em>loc1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> * <em>ent1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> * <em>head2</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__link.html#a4">link_loc_t</a> <em>loc2</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> * <em>ent2</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This function adds an entry to a sparse matrix. The entry is referenced in three different places, thus the complex set of arguments. This function will allocate a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> and return it through the <code>entry_p</code> result parameter.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>table</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>. </td></tr>
<tr><td valign=top><em>entry_p</em>
&nbsp;</td><td>
A pointer to a pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. This is a result parameter. If <code>NULL</code> is passed, the addition will be performed and an appropriate error code returned. </td></tr>
<tr><td valign=top><em>head1</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> representing a <a class="el" href="group__dbprim__smat.html#a48a102">SMAT_LOC_FIRST</a> sparse matrix list. </td></tr>
<tr><td valign=top><em>loc1</em>
&nbsp;</td><td>
A <a class="el" href="group__dbprim__link.html#a4">link_loc_t</a> indicating where the entry should be added for <code>head1</code>. </td></tr>
<tr><td valign=top><em>ent1</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> describing another element in the list represented by <code>head1</code> if <code>loc1</code> is <a class="el" href="group__dbprim__link.html#a26a100">LINK_LOC_BEFORE</a> or <a class="el" href="group__dbprim__link.html#a26a101">LINK_LOC_AFTER</a>. </td></tr>
<tr><td valign=top><em>head2</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> representing a <a class="el" href="group__dbprim__smat.html#a48a103">SMAT_LOC_SECOND</a> sparse matrix list. </td></tr>
<tr><td valign=top><em>loc2</em>
&nbsp;</td><td>
A <a class="el" href="group__dbprim__link.html#a4">link_loc_t</a> indicating where the entry should be added for <code>head2</code>. </td></tr>
<tr><td valign=top><em>ent2</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> describing another element in the list represented by <code>head2</code> if <code>loc2</code> is <a class="el" href="group__dbprim__link.html#a26a100">LINK_LOC_BEFORE</a> or <a class="el" href="group__dbprim__link.html#a26a101">LINK_LOC_AFTER</a>.</td></tr>
</table>
</dl><dl compact><dt>
<b>Return values: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DB_ERR_BADARGS</em>
&nbsp;</td><td>
An argument was invalid. </td></tr>
<tr><td valign=top><em>DB_ERR_BUSY</em>
&nbsp;</td><td>
One of the arguments is already in the table. </td></tr>
<tr><td valign=top><em>DB_ERR_FROZEN</em>
&nbsp;</td><td>
The table is currently frozen. </td></tr>
<tr><td valign=top><em>DB_ERR_NOTABLE</em>
&nbsp;</td><td>
The bucket table has not been allocated and automatic growth is not enabled. </td></tr>
<tr><td valign=top><em>DB_ERR_WRONGTABLE</em>
&nbsp;</td><td>
One of the arguments was not in the proper table or list. </td></tr>
<tr><td valign=top><em>DB_ERR_UNUSED</em>
&nbsp;</td><td>
One of the <code>ent</code> arguments is not presently in a list. </td></tr>
<tr><td valign=top><em>DB_ERR_UNRECOVERABLE</em>
&nbsp;</td><td>
An unrecoverable error occurred while resizing the table. </td></tr>
<tr><td valign=top><em>ENOMEM</em>
&nbsp;</td><td>
No memory could be allocated for the <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> structure. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a12" doxytag="st_find.c::st_find"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned long st_find (
          </b></td>
          <td valign="bottom"><b>
<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> * <em>table</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> ** <em>entry_p</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> * <em>head1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> * <em>head2</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This function looks up the entry matching the given <code>head1</code> and <code>head2</code>.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>table</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>. </td></tr>
<tr><td valign=top><em>entry_p</em>
&nbsp;</td><td>
A pointer to a pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a>. This is a result parameter. If <code>NULL</code> is passed, the lookup will be performed and an appropriate error code returned. </td></tr>
<tr><td valign=top><em>head1</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> initialized to <a class="el" href="group__dbprim__smat.html#a48a102">SMAT_LOC_FIRST</a>. </td></tr>
<tr><td valign=top><em>head2</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a1">smat_head_t</a> initialized to <a class="el" href="group__dbprim__smat.html#a48a103">SMAT_LOC_SECOND</a>.</td></tr>
</table>
</dl><dl compact><dt>
<b>Return values: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DB_ERR_BADARGS</em>
&nbsp;</td><td>
An argument was invalid. </td></tr>
<tr><td valign=top><em>DB_ERR_WRONGTABLE</em>
&nbsp;</td><td>
One or both of <code>head1</code> or <code>head2</code> are not referenced in this table. </td></tr>
<tr><td valign=top><em>DB_ERR_NOENTRY</em>
&nbsp;</td><td>
No matching entry was found. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a14" doxytag="st_flush.c::st_flush"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned long st_flush (
          </b></td>
          <td valign="bottom"><b>
<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> * <em>table</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a4">smat_iter_t</a> <em>flush_func</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
void * <em>extra</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This function flushes a sparse matrix--that is, it removes each entry from the matrix. If a <code>flush_func</code> is specified, it will be called on the entry after it has been removed from the table, and may safely call <code>free()</code>.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>table</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>. </td></tr>
<tr><td valign=top><em>flush_func</em>
&nbsp;</td><td>
A pointer to a callback function used to perform user-specified actions on an entry after removing it from the table. May be <code>NULL</code>. See the documentation for <a class="el" href="group__dbprim__smat.html#a4">smat_iter_t</a> for more information. </td></tr>
<tr><td valign=top><em>extra</em>
&nbsp;</td><td>
A <code>void</code> pointer that will be passed to <code>iter_func</code>.</td></tr>
</table>
</dl><dl compact><dt>
<b>Return values: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DB_ERR_BADARGS</em>
&nbsp;</td><td>
An argument was invalid. </td></tr>
<tr><td valign=top><em>DB_ERR_FROZEN</em>
&nbsp;</td><td>
The sparse matrix is frozen. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a16" doxytag="st_free.c::st_free"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned long st_free (
          </b></td>
          <td valign="bottom"><b>
<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> * <em>table</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This function releases the memory used by the bucket table of the empty hash table associated with a sparse matrix.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>table</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>.</td></tr>
</table>
</dl><dl compact><dt>
<b>Return values: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DB_ERR_BADARGS</em>
&nbsp;</td><td>
An invalid argument was given. </td></tr>
<tr><td valign=top><em>DB_ERR_FROZEN</em>
&nbsp;</td><td>
The table is frozen. </td></tr>
<tr><td valign=top><em>DB_ERR_NOTEMPTY</em>
&nbsp;</td><td>
The table is not empty. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a9" doxytag="st_init.c::st_init"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned long st_init (
          </b></td>
          <td valign="bottom"><b>
<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> * <em>table</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
unsigned long <em>flags</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a3">smat_resize_t</a> <em>resize</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
void * <em>extra</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
unsigned long <em>init_mod</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function dynamically initializes a sparse matrix table.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>table</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> to be initialized. </td></tr>
<tr><td valign=top><em>flags</em>
&nbsp;</td><td>
A bit-wise OR of <a class="el" href="group__dbprim__hash.html#a16">HASH_FLAG_AUTOGROW</a> and <a class="el" href="group__dbprim__hash.html#a17">HASH_FLAG_AUTOSHRINK</a>. If neither behavior is desired, use 0. </td></tr>
<tr><td valign=top><em>resize</em>
&nbsp;</td><td>
A <a class="el" href="group__dbprim__hash.html#a5">hash_resize_t</a> function pointer for determining whether resizing is permitted and/or for notification of the resize. </td></tr>
<tr><td valign=top><em>extra</em>
&nbsp;</td><td>
Extra pointer data that should be associated with the sparse matrix table. </td></tr>
<tr><td valign=top><em>init_mod</em>
&nbsp;</td><td>
An initial modulus for the table. This will presumably be extracted by <a class="el" href="group__dbprim__smat.html#a25">st_modulus</a>() in a previous invocation of the application. A 0 value is valid.</td></tr>
</table>
</dl><dl compact><dt>
<b>Return values: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DB_ERR_BADARGS</em>
&nbsp;</td><td>
An invalid argument was given. </td></tr>
<tr><td valign=top><em>ENOMEM</em>
&nbsp;</td><td>
Unable to allocate memory. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a13" doxytag="st_iter.c::st_iter"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned long st_iter (
          </b></td>
          <td valign="bottom"><b>
<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> * <em>table</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a4">smat_iter_t</a> <em>iter_func</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
void * <em>extra</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This function iterates over every entry in a sparse matrix (in an unspecified order), executing the given <code>iter_func</code> on each entry.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>table</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>. </td></tr>
<tr><td valign=top><em>iter_func</em>
&nbsp;</td><td>
A pointer to a callback function used to perform user-specified actions on an entry in a sparse matrix. <code>NULL</code> is an invalid value. See the documentation for <a class="el" href="group__dbprim__smat.html#a4">smat_iter_t</a> for more information. </td></tr>
<tr><td valign=top><em>extra</em>
&nbsp;</td><td>
A <code>void</code> pointer that will be passed to <code>iter_func</code>.</td></tr>
</table>
</dl><dl compact><dt>
<b>Return values: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DB_ERR_BADARGS</em>
&nbsp;</td><td>
An argument was invalid. </td></tr>
<tr><td valign=top><em>DB_ERR_FROZEN</em>
&nbsp;</td><td>
The sparse matrix is frozen. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a11" doxytag="st_remove.c::st_remove"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned long st_remove (
          </b></td>
          <td valign="bottom"><b>
<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> * <em>table</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
<a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> * <em>entry</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This function removes the given entry from the specified sparse matrix.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>table</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>. </td></tr>
<tr><td valign=top><em>entry</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a2">smat_entry_t</a> to be removed from the table.</td></tr>
</table>
</dl><dl compact><dt>
<b>Return values: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DB_ERR_BADARGS</em>
&nbsp;</td><td>
An invalid argument was given. </td></tr>
<tr><td valign=top><em>DB_ERR_WRONGTABLE</em>
&nbsp;</td><td>
Entry is not in this sparse matrix. </td></tr>
<tr><td valign=top><em>DB_ERR_UNRECOVERABLE</em>
&nbsp;</td><td>
An unrecoverable error occurred while removing the entry from the table. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a15" doxytag="st_resize.c::st_resize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
unsigned long st_resize (
          </b></td>
          <td valign="bottom"><b>
<a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a> * <em>table</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
unsigned long <em>new_size</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
 This function resizes the hash table associated with a sparse matrix based on the <code>new_size</code> parameter. See the documentation for <a class="el" href="group__dbprim__hash.html#a13">ht_resize</a>() for more information.<dl compact><dt>
<b>Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>table</em>
&nbsp;</td><td>
A pointer to a <a class="el" href="group__dbprim__smat.html#a0">smat_table_t</a>. </td></tr>
<tr><td valign=top><em>new_size</em>
&nbsp;</td><td>
A new size value for the table.</td></tr>
</table>
</dl><dl compact><dt>
<b>Return values: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>DB_ERR_BADARGS</em>
&nbsp;</td><td>
An argument was invalid. </td></tr>
<tr><td valign=top><em>DB_ERR_FROZEN</em>
&nbsp;</td><td>
The table is currently frozen. </td></tr>
<tr><td valign=top><em>DB_ERR_UNRECOVERABLE</em>
&nbsp;</td><td>
A catastrophic error was encountered. The table is now unusable. </td></tr>
<tr><td valign=top><em>ENOMEM</em>
&nbsp;</td><td>
No memory could be allocated for the new bucket table. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<hr><address><small>Generated at Thu Mar 6 21:23:10 2003 for dbprim by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.8.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
